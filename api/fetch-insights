// /api/fetch-insights.js

import { createClient } from '@supabase/supabase-js';

export const config = {
  api: {
    bodyParser: true,
  },
};

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// List of supported stat types and their matching columns in player_stats
const statMap = {
  points: 'pts',
  assists: 'ast',
  rebounds: 'reb',
  blocks: 'blk',
  steals: 'stl',
  threes: 'fg3m'
};

// Adaptive insight engine using 9-slot structure
export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ message: 'Only POST requests allowed' });
  }

  const legs = req.body;
  if (!Array.isArray(legs)) {
    return res.status(400).json({ message: 'Expected array of legs' });
  }

  const results = await Promise.all(
    legs.map(async (leg) => {
      const { player, prop, line, type } = leg;
      const insights = [];

      const statColumn = statMap[prop.toLowerCase()];
      if (!statColumn) {
        return { ...leg, insights: ["Unsupported prop type"] };
      }

      try {
        const { data: playerData, error: playerError } = await supabase
          .from('players')
          .select('player_id')
          .ilike('first_name', `%${player.split(' ')[0]}%`)
          .ilike('last_name', `%${player.split(' ')[1] || ''}%`)
          .limit(1)
          .maybeSingle();

        if (!playerData || playerError) {
          return { ...leg, insights: ["Player not found in database"] };
        }

        const playerId = playerData.player_id;

        // Last 10 Game Hit Rate
        const { data: recentStats } = await supabase
          .from('player_stats')
          .select(`${statColumn}`)
          .eq('player_id', playerId)
          .not(statColumn, 'is', null)
          .order('game_date', { ascending: false })
          .limit(10);

        const hits = recentStats.filter(row =>
          type === 'over' ? row[statColumn] > line : row[statColumn] < line
        ).length;

        const avg = recentStats.reduce((acc, cur) => acc + cur[statColumn], 0) / recentStats.length;

        insights.push(`Hit line in ${hits} of last 10 games.`);
        insights.push(`Averaging ${avg.toFixed(1)} ${prop} over last 10 games.`);

        // Additional insights could be added here from your SQL templates
        // e.g., season average, opponent defense ranking, home/away split, etc.

        return { ...leg, insights };
      } catch (err) {
        console.error(err);
        return { ...leg, insights: ["Error generating insights"] };
      }
    })
  );

  return res.status(200).json(results);
}

/*
GPT Prompt (internal):
You are generating player prop betting insights using Supabase. Use the following table schema:

- player_stats (game_id, player_id, game_date, pts, reb, ast, blk, stl, fg3m, min, etc.)
- players (player_id, first_name, last_name)
- games (id, date, home_team_id, visitor_team_id)
- box_scores, advanced_stats, player_injuries, season_averages, etc.

Each uploaded bet leg contains: player name, prop type (e.g. points), line, and over/under.

For each prop:
- Select 6 basic insights (e.g., hit rate, average stat, matchup history, home vs away)
- Select 3 advanced insights (e.g., pace, opponent defense ranking, injury impact)
- Adapt all logic based on the prop type (e.g., points → pts, assists → ast, blocks → blk)
- Do NOT return scoring-specific insights for rebound or 3PT bets — adjust context dynamically.
*/
